
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">models/avatar.go (84.0%)</option>
				
				<option value="file1">models/channels.go (83.3%)</option>
				
				<option value="file2">models/emojis.go (85.2%)</option>
				
				<option value="file3">models/roles.go (87.9%)</option>
				
				<option value="file4">models/user.go (92.4%)</option>
				
				<option value="file5">models/utilities.go (51.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package models

import (
        "encoding/json"
        "io"
)

type Avatar struct {
        Name string `json:"name"`
        Link string `json:"link"`
}

func (avatar *Avatar) isValid() *AppError <span class="cov8" title="1">{
        if len(avatar.Name) == 0 || len(avatar.Name) &gt; 64 </span><span class="cov8" title="1">{
                return NewLocAppError("Avatar.IsValid", "model.avatar.name.app_error", nil, "")
        }</span>

        <span class="cov8" title="1">if len(avatar.Link) == 0 </span><span class="cov8" title="1">{
                return NewLocAppError("Avatar.IsValid", "model.avatar.link.app_error", nil, "")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (avatar *Avatar) toJson() string <span class="cov8" title="1">{
        b, err := json.Marshal(avatar)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov8" title="1"> else {
                return string(b)
        }</span>
}

func avatarFromJson(data io.Reader) *Avatar <span class="cov8" title="1">{
        decoder := json.NewDecoder(data)
        var avatar Avatar
        err := decoder.Decode(&amp;avatar)
        if err == nil </span><span class="cov8" title="1">{
                return &amp;avatar
        }</span><span class="cov0" title="0"> else {
                return nil
        }</span>
}

func avatarListToJson(avatarList []*Avatar) string <span class="cov8" title="1">{
        b, err := json.Marshal(avatarList)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov8" title="1"> else {
                return string(b)
        }</span>
}

func avatarListFromJson(data io.Reader) []*Avatar <span class="cov8" title="1">{
        decoder := json.NewDecoder(data)
        var avatarList []*Avatar
        err := decoder.Decode(&amp;avatarList)
        if err == nil </span><span class="cov8" title="1">{
                return avatarList
        }</span><span class="cov0" title="0"> else {
                return nil
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package models

import (
        "encoding/json"
        "io"
        "strings"
        "unicode/utf8"
)

const (
        DEFAULT_CHANNEL                = "general"
        CHANNEL_DISPLAY_NAME_MAX_RUNES = 64
        CHANNEL_NAME_MAX_LENGTH        = 64
        CHANNEL_DESCRIPTION_MAX_RUNES  = 1024
        CHANNEL_SUBJECT_MAX_RUNES      = 250
)

var (
        CHANNNEL_AVAILABLE_TYPES = []string{"direct", "text", "audio", "video"}
)

type Channel struct {
        WebId       string `json:"web_id"`
        Type        string `json:"type"`
        ChannelName string `json:"display_name"`
        UpdatedAt   int64  `json:"updated_at,omitempty"`
        Private     bool   `json:"private"`
        Description string `json:"description"`
        Subject     string `json:"subject"`
        Avatar      string `json:"avatar,omitempty"`
}

func (channel *Channel) toJson() string <span class="cov8" title="1">{
        b, err := json.Marshal(channel)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov8" title="1"> else {
                return string(b)
        }</span>
}

func channelFromJson(data io.Reader) *Channel <span class="cov8" title="1">{
        decoder := json.NewDecoder(data)
        var channel Channel
        err := decoder.Decode(&amp;channel)
        if err == nil </span><span class="cov8" title="1">{
                return &amp;channel
        }</span><span class="cov0" title="0"> else {
                return nil
        }</span>
}

func (channel *Channel) etag() string <span class="cov0" title="0">{
        return Etag(channel.WebId, channel.UpdatedAt)
}</span>

func (channel *Channel) isValid() *AppError <span class="cov8" title="1">{

        if len(channel.WebId) != 26 </span><span class="cov8" title="1">{
                return NewLocAppError("Channel.IsValid", "model.channel.is_valid.id.app_error", nil, "")
        }</span>

        <span class="cov8" title="1">if channel.UpdatedAt == 0 </span><span class="cov8" title="1">{
                return NewLocAppError("Channel.IsValid", "model.channel.is_valid.update_at.app_error", nil, "id="+channel.WebId)
        }</span>

        <span class="cov8" title="1">if utf8.RuneCountInString(channel.ChannelName) &gt; CHANNEL_DISPLAY_NAME_MAX_RUNES </span><span class="cov8" title="1">{
                return NewLocAppError("Channel.IsValid", "model.channel.is_valid.channel_name.app_error", nil, "id="+channel.WebId)
        }</span>

        <span class="cov8" title="1">if !IsValidChannelIdentifier(channel.ChannelName) </span><span class="cov8" title="1">{
                return NewLocAppError("Channel.IsValid", "model.channel.is_valid.not_alphanum_channel_name.app_error", nil, "id="+channel.WebId)
        }</span>

        <span class="cov8" title="1">if utf8.RuneCountInString(channel.Description) &gt; CHANNEL_DESCRIPTION_MAX_RUNES </span><span class="cov8" title="1">{
                return NewLocAppError("Channel.IsValid", "model.channel.is_valid.description.app_error", nil, "id="+channel.WebId)
        }</span>

        <span class="cov8" title="1">if utf8.RuneCountInString(channel.Subject) &gt; CHANNEL_SUBJECT_MAX_RUNES </span><span class="cov8" title="1">{
                return NewLocAppError("Channel.IsValid", "model.channel.is_valid.subject.app_error", nil, "id="+channel.WebId)
        }</span>

        <span class="cov8" title="1">if !StringInArray(channel.Type, CHANNNEL_AVAILABLE_TYPES) </span><span class="cov8" title="1">{
                return NewLocAppError("Channel.IsValid", "model.channel.is_valid.type.app_error", nil, "id="+channel.WebId)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (channel *Channel) preSave() <span class="cov8" title="1">{
        if channel.WebId == "" </span><span class="cov8" title="1">{
                channel.WebId = NewId()
        }</span>

        <span class="cov8" title="1">if channel.ChannelName == "" </span><span class="cov8" title="1">{
                channel.ChannelName = NewId()
        }</span>

        <span class="cov8" title="1">channel.ChannelName = strings.ToLower(channel.ChannelName)

        channel.UpdatedAt = GetMillis()

        if channel.Avatar == "" </span><span class="cov8" title="1">{
                channel.Avatar = "default_channel_avatar.svg"
        }</span>

        <span class="cov8" title="1">if channel.Type == "" </span><span class="cov8" title="1">{
                channel.Type = "text"
        }</span>

        <span class="cov8" title="1">if channel.Type == "direct" </span><span class="cov0" title="0">{
                channel.Private = true
        }</span>
}

func (channel *Channel) preUpdate() <span class="cov8" title="1">{
        channel.UpdatedAt = GetMillis()
}</span>

func getDMNameFromIds(userId1, userId2 string) string <span class="cov0" title="0">{
        if userId1 &gt; userId2 </span><span class="cov0" title="0">{
                return userId2 + "__" + userId1
        }</span><span class="cov0" title="0"> else {
                return userId1 + "__" + userId2
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package models

import (
        "encoding/json"
        "io"
)

type Emoji struct {
        Name     string `json:"name"`
        ShortCut string `json:"shortcut"`
        Link     string `json:"link"`
}

func (emoji *Emoji) isValid() *AppError <span class="cov8" title="1">{
        if len(emoji.Name) == 0 || len(emoji.Name) &gt; 64 </span><span class="cov8" title="1">{
                return NewLocAppError("Emoji.IsValid", "model.emoji.name.app_error", nil, "")
        }</span>

        <span class="cov8" title="1">if len(emoji.ShortCut) == 0 || len(emoji.ShortCut) &gt; 20 </span><span class="cov8" title="1">{
                return NewLocAppError("Emoji.IsValid", "model.emoji.shortcut.app_error", nil, "")
        }</span>

        <span class="cov8" title="1">if len(emoji.Link) == 0 </span><span class="cov8" title="1">{
                return NewLocAppError("Emoji.IsValid", "model.emoji.link.app_error", nil, "")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (emoji *Emoji) toJson() string <span class="cov8" title="1">{
        b, err := json.Marshal(emoji)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov8" title="1"> else {
                return string(b)
        }</span>
}

func emojiFromJson(data io.Reader) *Emoji <span class="cov8" title="1">{
        decoder := json.NewDecoder(data)
        var emoji Emoji
        err := decoder.Decode(&amp;emoji)
        if err == nil </span><span class="cov8" title="1">{
                return &amp;emoji
        }</span><span class="cov0" title="0"> else {
                return nil
        }</span>
}

func emojiListToJson(emojiList []*Emoji) string <span class="cov8" title="1">{
        b, err := json.Marshal(emojiList)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov8" title="1"> else {
                return string(b)
        }</span>
}

func emojiListFromJson(data io.Reader) []*Emoji <span class="cov8" title="1">{
        decoder := json.NewDecoder(data)
        var emojiList []*Emoji
        err := decoder.Decode(&amp;emojiList)
        if err == nil </span><span class="cov8" title="1">{
                return emojiList
        }</span><span class="cov0" title="0"> else {
                return nil
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package models

import (
        "encoding/json"
        "io"
        "regexp"
)

type Role struct {
        RoleId        uint   `gorm:"primary_key;column:roleId;AUTO_INCREMENT" json:"-"`
        RoleName      string `gorm:"column:roleName;unique_index" json:"name"`
        CanUsePrivate bool   `gorm:"column:canUsePrivate" json:"canUsePrivate"`
        CanModerate   bool   `gorm:"column:canModerate" json:"canModerate"`
        CanArchive    bool   `gorm:"column:canArchive" json:"canArchive"`
        CanInvite     bool   `gorm:"column:canInvite" json:"canInvite"`
        CanManage     bool   `gorm:"column:canManage" json:"canManage"`
        CanManageUser bool   `gorm:"column:canManageUser" json:"canManageUser"`
}

var (
        OWNER = Role{
                RoleName:      "owner",
                CanUsePrivate: true,
                CanModerate:   true,
                CanArchive:    true,
                CanInvite:     true,
                CanManage:     true,
                CanManageUser: true,
        }
        ADMIN = Role{
                RoleName:      "admin",
                CanUsePrivate: true,
                CanModerate:   true,
                CanArchive:    true,
                CanInvite:     true,
                CanManage:     true,
                CanManageUser: true,
        }
        STANDART = Role{
                RoleName:      "standart",
                CanUsePrivate: true,
                CanModerate:   true,
                CanArchive:    true,
                CanInvite:     false,
                CanManage:     false,
                CanManageUser: false,
        }
        GUEST = Role{
                RoleName:      "guest",
                CanUsePrivate: false,
                CanModerate:   false,
                CanArchive:    false,
                CanInvite:     false,
                CanManage:     false,
                CanManageUser: false,
        }
        BASICS_ROLES = []*Role{
                &amp;OWNER,
                &amp;ADMIN,
                &amp;STANDART,
                &amp;GUEST,
        }
        restrictedRoleNames = []string{
                "owner",
                "admin",
                "standart",
                "guest",
        }
        validRoleNameChars = regexp.MustCompile(`^[a-z]+$`)
)

func (role *Role) isValid() *AppError <span class="cov8" title="1">{
        if !isValidRoleName(role.RoleName) </span><span class="cov8" title="1">{
                return NewLocAppError("Role.IsValid", "model.role.rolename.app_error", nil, "")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (role *Role) preSave() <span class="cov8" title="1">{
        if role.RoleName == "" </span><span class="cov8" title="1">{
                role.RoleName = NewId()
        }</span>
}

func (role *Role) toJson() string <span class="cov8" title="1">{
        b, err := json.Marshal(role)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov8" title="1"> else {
                return string(b)
        }</span>
}

func isValidRoleName(u string) bool <span class="cov8" title="1">{
        if len(u) == 0 || len(u) &gt; 64 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if !validRoleNameChars.MatchString(u) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, restrictedRoleName := range restrictedRoleNames </span><span class="cov8" title="1">{
                if u == restrictedRoleName </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func roleFromJson(data io.Reader) *Role <span class="cov8" title="1">{
        decoder := json.NewDecoder(data)
        var role Role
        err := decoder.Decode(&amp;role)
        if err == nil </span><span class="cov8" title="1">{
                return &amp;role
        }</span><span class="cov0" title="0"> else {
                return nil
        }</span>
}

func roleListToJson(roleList []*Role) string <span class="cov8" title="1">{
        b, err := json.Marshal(roleList)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov8" title="1"> else {
                return string(b)
        }</span>
}

func roleListFromJson(data io.Reader) []*Role <span class="cov8" title="1">{
        decoder := json.NewDecoder(data)
        var roleList []*Role
        err := decoder.Decode(&amp;roleList)
        if err == nil </span><span class="cov8" title="1">{
                return roleList
        }</span><span class="cov0" title="0"> else {
                return nil
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Here is the file which describe the user model.
// It provwebIdes bascis function to manipulate the model.
package models

import (
        "encoding/json"
        "fmt"
        "io"
        "regexp"
        "strings"
        "unicode/utf8"

        "golang.org/x/crypto/bcrypt"
)

const (
        user_NOTIFY_ALL            = "all"
        user_NOTIFY_MENTION        = "mention"
        user_NOTIFY_NONE           = "none"
        DEFAULT_locale             = "en"
        user_AUTH_SERVICE_email    = "email"
        user_AUTH_SERVICE_username = "username"
)

var (
        user_CHANNEL        = []string{"general", "random"}
        restrictedUsernames = []string{
                "all",
                "channel",
                "popcubebot",
                "here",
        }
        validUsernameChars = regexp.MustCompile(`^[a-z0-9\.\-_]+$`)
)

// Used in mattermost project ... Don't think they are relevant for us.
//        MfaActive          bool      `json:"mfa_active,omitempty"`
//        MfaSecret          string    `json:"mfa_secret,omitempty"`

// user object
//
// - webwebId: String unique and non null to webIdentify the user on application services. - REQUIRED
//
// - username: Store the user username used to log into the service. - REQUIRED
//
// - email: user mail ;). - REQUIRED
//
// - emailVerified: true if email was verified by user. - REQUIRED
//
// - updatedAt: Time of the last update. Used to create tag for browser cache. - REQUIRED
//
// - deleted: True if user is deleted. - REQUIRED
//
// - password: Hashed password. - REQUIRED
//
// - lastpasswordUpdate: Date of the last password modification. - REQUIRED
//
// - failedAttemps: Number of fail try to connect to account. - REQUIRED
//
// - locale: user favorite langage. - REQUIRED
//
// - role : int referencing a user role existing in the database. - REQUIRED
//
// - nickname: Name to use in communication channel (by default : username).
//
// - first name: user true first name.
//
// - last name: user true last name.
//
// - lastActivityAt: Date &amp;&amp; Time of the last activity of the user.
type User struct {
        WebId              string `json:"webId"`
        UpdatedAt          int64  `json:"update_at,omitempty"`
        Deleted            bool   `json:"deleted"`
        Username           string `json:"username"`
        Password           string `json:"password,omitempty"`
        Email              string `json:"email,omitempty"`
        EmailVerified      bool   `json:"email_verified,omitempty"`
        Nickname           string `json:"nickname"`
        FirstName          string `json:"first_name"`
        LastName           string `json:"last_name"`
        Avatar             string `json:"avatar"`
        Role               int64  `json:"roles,omitempty"`
        LastPasswordUpdate int64  `json:"last_password_update,omitempty"`
        FailedAttempts     int    `json:"failed_attempts,omitempty"`
        Locale             string `json:"locale"`
        LastActivityAt     int64  `db:"-" json:"last_activity_at,omitempty"`
}

// isValid valwebIdates the user and returns an error if it isn't configured
// correctly.
func (u *User) isValid() *AppError <span class="cov8" title="1">{

        if len(u.WebId) != 26 </span><span class="cov8" title="1">{
                return NewLocAppError("user.isValid", "model.user.is_valid.WebId.app_error", nil, "")
        }</span>

        <span class="cov8" title="1">if !isValidUsername(u.Username) </span><span class="cov8" title="1">{
                return NewLocAppError("user.isValid", "model.user.is_valid.Username.app_error", nil, "user_webId="+u.WebId)
        }</span>

        <span class="cov8" title="1">if len(u.Email) == 0 || len(u.Email) &gt; 128 || !IsValidEmail(u.Email) </span><span class="cov8" title="1">{
                return NewLocAppError("user.isValid", "model.user.is_valid.Email.app_error", nil, "user_webId="+u.WebId)
        }</span>

        <span class="cov8" title="1">if utf8.RuneCountInString(u.Nickname) &gt; 64 </span><span class="cov8" title="1">{
                return NewLocAppError("user.isValid", "model.user.is_valid.Nickname.app_error", nil, "user_webId="+u.WebId)
        }</span>

        <span class="cov8" title="1">if utf8.RuneCountInString(u.FirstName) &gt; 64 </span><span class="cov8" title="1">{
                return NewLocAppError("user.isValid", "model.user.is_valid.first_name.app_error", nil, "user_webId="+u.WebId)
        }</span>

        <span class="cov8" title="1">if utf8.RuneCountInString(u.LastName) &gt; 64 </span><span class="cov8" title="1">{
                return NewLocAppError("user.isValid", "model.user.is_valid.last_name.app_error", nil, "user_webId="+u.WebId)
        }</span>

        <span class="cov8" title="1">if len(u.Password) == 0 </span><span class="cov8" title="1">{
                return NewLocAppError("user.isValid", "model.user.is_valid.auth_data_pwd.app_error", nil, "user_webId="+u.WebId)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// preSave have to be run before saving user in DB. It will fill necessary information (webId, username, etc. ) and hash password
func (u *User) preSave() <span class="cov8" title="1">{
        if u.WebId == "" </span><span class="cov8" title="1">{
                u.WebId = NewId()
        }</span>

        <span class="cov8" title="1">if u.Username == "" </span><span class="cov8" title="1">{
                u.Username = NewId()
        }</span>

        <span class="cov8" title="1">u.Username = strings.ToLower(u.Username)
        u.Email = strings.ToLower(u.Email)

        u.UpdatedAt = GetMillis()
        u.LastPasswordUpdate = u.UpdatedAt

        if u.Locale == "" </span><span class="cov8" title="1">{
                u.Locale = DEFAULT_locale
        }</span>

        <span class="cov8" title="1">if len(u.Password) &gt; 0 </span><span class="cov8" title="1">{
                u.Password = hashPassword(u.Password)
        }</span>
}

// preSave will set the webId and username if missing.  It will also fill
// in the CreateAt, UpdateAt times.  It will also hash the password.  It should
// be run before saving the user to the db.
// PreUpdate should be run before updating the user in the db.
func (u *User) preUpdate() <span class="cov0" title="0">{
        u.Username = strings.ToLower(u.Username)
        u.Email = strings.ToLower(u.Email)
        u.UpdatedAt = GetMillis()
}</span>

// ToJson convert a user to a json string
func (u *User) toJson() string <span class="cov8" title="1">{
        b, err := json.Marshal(u)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov8" title="1"> else {
                return string(b)
        }</span>
}

// userFromJson will decode the input and return a user
func userFromJson(data io.Reader) *User <span class="cov8" title="1">{
        decoder := json.NewDecoder(data)
        var user User
        err := decoder.Decode(&amp;user)
        if err == nil </span><span class="cov8" title="1">{
                return &amp;user
        }</span><span class="cov0" title="0"> else {
                return nil
        }</span>
}

func isValidUsername(u string) bool <span class="cov8" title="1">{
        if len(u) == 0 || len(u) &gt; 64 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if !validUsernameChars.MatchString(u) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, restrictedUsername := range restrictedUsernames </span><span class="cov8" title="1">{
                if u == restrictedUsername </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// Generate a valwebId strong etag so the browser can cache the results
func (u *User) etag(showFullName, showemail bool) string <span class="cov8" title="1">{
        return Etag(u.WebId, u.UpdatedAt, showFullName, showemail)
}</span>

// Get full name of the user
func (u *User) getFullName() string <span class="cov8" title="1">{
        if u.LastName == "" </span><span class="cov8" title="1">{
                return u.FirstName
        }</span>
        <span class="cov8" title="1">if u.FirstName == "" </span><span class="cov8" title="1">{
                return u.LastName
        }</span>
        <span class="cov8" title="1">return u.FirstName + " " + u.LastName</span>
}

// Get full name of the user
func (u *User) getDisplayName() string <span class="cov8" title="1">{
        if u.Nickname != "" </span><span class="cov8" title="1">{
                return u.Nickname
        }</span>
        <span class="cov8" title="1">if u.getFullName() != "" </span><span class="cov8" title="1">{
                return u.getFullName()
        }</span>
        <span class="cov8" title="1">return u.Username</span>
}

// hashpassword generates a hash using the bcrypt.GenerateFrompassword
func hashPassword(password string) string <span class="cov8" title="1">{
        hash, err := bcrypt.GenerateFromPassword([]byte(password), 10)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return string(hash)</span>
}

// Comparepassword compares the hash
func comparePassword(hash string, password string) bool <span class="cov8" title="1">{

        if len(password) == 0 || len(hash) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil</span>
}

// Transform user name to meet requirement
func cleanUsername(s string) string <span class="cov8" title="1">{
        s = strings.ToLower(strings.Replace(s, " ", "-", -1))

        for _, value := range reservedName </span><span class="cov8" title="1">{
                if s == value </span><span class="cov8" title="1">{
                        s = strings.Replace(s, value, "", -1)
                }</span>
        }

        <span class="cov8" title="1">s = strings.TrimSpace(s)

        for _, c := range s </span><span class="cov8" title="1">{
                char := fmt.Sprintf("%c", c)
                if !validUsernameChars.MatchString(char) </span><span class="cov8" title="1">{
                        s = strings.Replace(s, char, "-", -1)
                }</span>
        }

        <span class="cov8" title="1">if !isValidUsername(s) </span><span class="cov8" title="1">{
                s = "a" + NewId()
        }</span>

        <span class="cov8" title="1">return s</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright (c) 2015 Mattermost, Inc. All Rights Reserved.
// See License.txt for license information.
package models

import (
        "bytes"
        "crypto/rand"
        "encoding/base32"
        "encoding/json"
        "fmt"
        "io"
        "io/ioutil"
        "net/mail"
        "net/url"
        "regexp"
        "strings"
        "time"

        goi18n "github.com/nicksnyder/go-i18n/i18n"
        "github.com/pborman/uuid"
)

const (
        LOWERCASE_LETTERS = "abcdefghijklmnopqrstuvwxyz"
        UPPERCASE_LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        NUMBERS           = "0123456789"
        SYMBOLS           = " !\"\\#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`|~"
        CURRENT_VERSION   = "0.0.0"
)

type StringInterface map[string]interface{}
type StringMap map[string]string
type StringArray []string
type EncryptStringMap map[string]string

type AppError struct {
        Id            string                 `json:"id"`
        Message       string                 `json:"message"`               // Message to be display to the end user without debugging information
        DetailedError string                 `json:"detailed_error"`        // Internal error string to help the developer
        RequestId     string                 `json:"request_id,omitempty"`  // The RequestId that's also set in the header
        StatusCode    int                    `json:"status_code,omitempty"` // The http status code
        Where         string                 `json:"-"`                     // The function where it happened in the form of Struct.Func
        IsOAuth       bool                   `json:"is_oauth,omitempty"`    // Whether the error is OAuth specific
        params        map[string]interface{} `json:"-"`
}

func (er *AppError) Error() string <span class="cov8" title="1">{
        return er.Where + ": " + er.Message + ", " + er.DetailedError
}</span>

func (er *AppError) Translate(T goi18n.TranslateFunc) <span class="cov0" title="0">{
        if er.params == nil </span><span class="cov0" title="0">{
                er.Message = T(er.Id)
        }</span><span class="cov0" title="0"> else {
                er.Message = T(er.Id, er.params)
        }</span>
}

func (er *AppError) SystemMessage(T goi18n.TranslateFunc) string <span class="cov0" title="0">{
        if er.params == nil </span><span class="cov0" title="0">{
                return T(er.Id)
        }</span><span class="cov0" title="0"> else {
                return T(er.Id, er.params)
        }</span>
}

func (er *AppError) ToJson() string <span class="cov8" title="1">{
        b, err := json.Marshal(er)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov8" title="1"> else {
                return string(b)
        }</span>
}

// AppErrorFromJson will decode the input and return an AppError
func AppErrorFromJson(data io.Reader) *AppError <span class="cov8" title="1">{
        str := ""
        bytes, rerr := ioutil.ReadAll(data)
        if rerr != nil </span><span class="cov0" title="0">{
                str = rerr.Error()
        }</span><span class="cov8" title="1"> else {
                str = string(bytes)
        }</span>

        <span class="cov8" title="1">decoder := json.NewDecoder(strings.NewReader(str))
        var er AppError
        err := decoder.Decode(&amp;er)
        if err == nil </span><span class="cov8" title="1">{
                return &amp;er
        }</span><span class="cov8" title="1"> else {
                return NewLocAppError("AppErrorFromJson", "model.utils.decode_json.app_error", nil, "body: "+str)
        }</span>
}

func NewLocAppError(where string, id string, params map[string]interface{}, details string) *AppError <span class="cov8" title="1">{
        ap := &amp;AppError{}
        ap.Id = id
        ap.params = params
        ap.Message = id
        ap.Where = where
        ap.DetailedError = details
        ap.StatusCode = 500
        ap.IsOAuth = false
        return ap
}</span>

var encoding = base32.NewEncoding("ybndrfg8ejkmcpqxot1uwisza345h769")

// NewId is a globally unique identifier.  It is a [A-Z0-9] string 26
// characters long.  It is a UUID version 4 Guid that is zbased32 encoded
// with the padding stripped off.
func NewId() string <span class="cov8" title="1">{
        var b bytes.Buffer
        encoder := base32.NewEncoder(encoding, &amp;b)
        encoder.Write(uuid.NewRandom())
        encoder.Close()
        b.Truncate(26) // removes the '==' padding
        return b.String()
}</span>

func NewRandomString(length int) string <span class="cov8" title="1">{
        var b bytes.Buffer
        str := make([]byte, length+8)
        rand.Read(str)
        encoder := base32.NewEncoder(encoding, &amp;b)
        encoder.Write(str)
        encoder.Close()
        b.Truncate(length) // removes the '==' padding
        return b.String()
}</span>

// GetMillis is a convience method to get milliseconds since epoch.
func GetMillis() int64 <span class="cov8" title="1">{
        return time.Now().UnixNano() / int64(time.Millisecond)
}</span>

// MapToJson converts a map to a json string
func MapToJson(objmap map[string]string) string <span class="cov8" title="1">{
        if b, err := json.Marshal(objmap); err != nil </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov8" title="1"> else {
                return string(b)
        }</span>
}

// MapFromJson will decode the key/value pair map
func MapFromJson(data io.Reader) map[string]string <span class="cov8" title="1">{
        decoder := json.NewDecoder(data)

        var objmap map[string]string
        if err := decoder.Decode(&amp;objmap); err != nil </span><span class="cov8" title="1">{
                return make(map[string]string)
        }</span><span class="cov8" title="1"> else {
                return objmap
        }</span>
}

func ArrayToJson(objmap []string) string <span class="cov0" title="0">{
        if b, err := json.Marshal(objmap); err != nil </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov0" title="0"> else {
                return string(b)
        }</span>
}

func ArrayFromJson(data io.Reader) []string <span class="cov0" title="0">{
        decoder := json.NewDecoder(data)

        var objmap []string
        if err := decoder.Decode(&amp;objmap); err != nil </span><span class="cov0" title="0">{
                return make([]string, 0)
        }</span><span class="cov0" title="0"> else {
                return objmap
        }</span>
}

func ArrayFromInterface(data interface{}) []string <span class="cov0" title="0">{
        stringArray := []string{}

        dataArray, ok := data.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return stringArray
        }</span>

        <span class="cov0" title="0">for _, v := range dataArray </span><span class="cov0" title="0">{
                if str, ok := v.(string); ok </span><span class="cov0" title="0">{
                        stringArray = append(stringArray, str)
                }</span>
        }

        <span class="cov0" title="0">return stringArray</span>
}

func StringInArray(a string, array []string) bool <span class="cov8" title="1">{
        for _, b := range array </span><span class="cov8" title="1">{
                if b == a </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func StringInterfaceToJson(objmap map[string]interface{}) string <span class="cov0" title="0">{
        if b, err := json.Marshal(objmap); err != nil </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov0" title="0"> else {
                return string(b)
        }</span>
}

func StringInterfaceFromJson(data io.Reader) map[string]interface{} <span class="cov0" title="0">{
        decoder := json.NewDecoder(data)

        var objmap map[string]interface{}
        if err := decoder.Decode(&amp;objmap); err != nil </span><span class="cov0" title="0">{
                return make(map[string]interface{})
        }</span><span class="cov0" title="0"> else {
                return objmap
        }</span>
}

func StringToJson(s string) string <span class="cov0" title="0">{
        b, err := json.Marshal(s)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov0" title="0"> else {
                return string(b)
        }</span>
}

func StringFromJson(data io.Reader) string <span class="cov0" title="0">{
        decoder := json.NewDecoder(data)

        var s string
        if err := decoder.Decode(&amp;s); err != nil </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov0" title="0"> else {
                return s
        }</span>
}

func IsLower(s string) bool <span class="cov8" title="1">{
        if strings.ToLower(s) == s </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

func IsValidEmail(email string) bool <span class="cov8" title="1">{

        if !IsLower(email) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if _, err := mail.ParseAddress(email); err == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

var reservedName = []string{
        "signup",
        "login",
        "admin",
        "channel",
        "post",
        "api",
        "oauth",
}

func IsValidChannelIdentifier(s string) bool <span class="cov8" title="1">{

        if !IsValidAlphaNum(s, true) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

var validAlphaNumUnderscore = regexp.MustCompile(`^[a-z0-9]+([a-z\-\_0-9]+|(__)?)[a-z0-9]+$`)
var validAlphaNum = regexp.MustCompile(`^[a-z0-9]+([a-z\-0-9]+|(__)?)[a-z0-9]+$`)

func IsValidAlphaNum(s string, allowUnderscores bool) bool <span class="cov8" title="1">{
        var match bool
        if allowUnderscores </span><span class="cov8" title="1">{
                match = validAlphaNumUnderscore.MatchString(s)
        }</span><span class="cov0" title="0"> else {
                match = validAlphaNum.MatchString(s)
        }</span>

        <span class="cov8" title="1">if !match </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

func Etag(parts ...interface{}) string <span class="cov8" title="1">{

        etag := CURRENT_VERSION

        for _, part := range parts </span><span class="cov8" title="1">{
                etag += fmt.Sprintf(".%v", part)
        }</span>

        <span class="cov8" title="1">return etag</span>
}

var validHashtag = regexp.MustCompile(`^(#\pL[\pL\d\-_.]*[\pL\d])$`)
var puncStart = regexp.MustCompile(`^[^\pL\d\s#]+`)
var hashtagStart = regexp.MustCompile(`^#{2,}`)
var puncEnd = regexp.MustCompile(`[^\pL\d\s]+$`)

func ParseHashtags(text string) (string, string) <span class="cov8" title="1">{
        words := strings.Fields(text)

        hashtagString := ""
        plainString := ""
        for _, word := range words </span><span class="cov8" title="1">{
                // trim off surrounding punctuation
                word = puncStart.ReplaceAllString(word, "")
                word = puncEnd.ReplaceAllString(word, "")

                // and remove extra pound #s
                word = hashtagStart.ReplaceAllString(word, "#")

                if validHashtag.MatchString(word) </span><span class="cov8" title="1">{
                        hashtagString += " " + word
                }</span><span class="cov8" title="1"> else {
                        plainString += " " + word
                }</span>
        }

        <span class="cov8" title="1">if len(hashtagString) &gt; 1000 </span><span class="cov0" title="0">{
                hashtagString = hashtagString[:999]
                lastSpace := strings.LastIndex(hashtagString, " ")
                if lastSpace &gt; -1 </span><span class="cov0" title="0">{
                        hashtagString = hashtagString[:lastSpace]
                }</span><span class="cov0" title="0"> else {
                        hashtagString = ""
                }</span>
        }

        <span class="cov8" title="1">return strings.TrimSpace(hashtagString), strings.TrimSpace(plainString)</span>
}

// func IsFileExtImage(ext string) bool {
//         ext = strings.ToLower(ext)
//         for _, imgExt := range IMAGE_EXTENSIONS {
//                 if ext == imgExt {
//                         return true
//                 }
//         }
//         return false
// }

// func GetImageMimeType(ext string) string {
//         ext = strings.ToLower(ext)
//         if len(IMAGE_MIME_TYPES[ext]) == 0 {
//                 return "image"
//         } else {
//                 return IMAGE_MIME_TYPES[ext]
//         }
// }

func ClearMentionTags(post string) string <span class="cov0" title="0">{
        post = strings.Replace(post, "&lt;mention&gt;", "", -1)
        post = strings.Replace(post, "&lt;/mention&gt;", "", -1)
        return post
}</span>

var UrlRegex = regexp.MustCompile(`^((?:[a-z]+:\/\/)?(?:(?:[a-z0-9\-]+\.)+(?:[a-z]{2}|aero|arpa|biz|com|coop|edu|gov|info|int|jobs|mil|museum|name|nato|net|org|pro|travel|local|internal))(:[0-9]{1,5})?(?:\/[a-z0-9_\-\.~]+)*(\/([a-z0-9_\-\.]*)(?:\?[a-z0-9+_~\-\.%=&amp;amp;]*)?)?(?:#[a-zA-Z0-9!$&amp;'()*+.=-_~:@/?]*)?)(?:\s+|$)$`)
var PartialUrlRegex = regexp.MustCompile(`/([A-Za-z0-9]{26})/([A-Za-z0-9]{26})/((?:[A-Za-z0-9]{26})?.+(?:\.[A-Za-z0-9]{3,})?)`)

var SplitRunes = map[rune]bool{',': true, ' ': true, '.': true, '!': true, '?': true, ':': true, ';': true, '\n': true, '&lt;': true, '&gt;': true, '(': true, ')': true, '{': true, '}': true, '[': true, ']': true, '+': true, '/': true, '\\': true}

func IsValidHttpUrl(rawUrl string) bool <span class="cov0" title="0">{
        if strings.Index(rawUrl, "http://") != 0 &amp;&amp; strings.Index(rawUrl, "https://") != 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if _, err := url.ParseRequestURI(rawUrl); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func IsValidHttpsUrl(rawUrl string) bool <span class="cov0" title="0">{
        if strings.Index(rawUrl, "https://") != 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if _, err := url.ParseRequestURI(rawUrl); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func IsValidTurnOrStunServer(rawUri string) bool <span class="cov0" title="0">{
        if strings.Index(rawUri, "turn:") != 0 &amp;&amp; strings.Index(rawUri, "stun:") != 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if _, err := url.ParseRequestURI(rawUri); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func IsSafeLink(link *string) bool <span class="cov0" title="0">{
        if link != nil </span><span class="cov0" title="0">{
                if IsValidHttpUrl(*link) </span><span class="cov0" title="0">{
                        return true
                }</span><span class="cov0" title="0"> else if strings.HasPrefix(*link, "/") </span><span class="cov0" title="0">{
                        return true
                }</span><span class="cov0" title="0"> else {
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

func IsValidWebsocketUrl(rawUrl string) bool <span class="cov0" title="0">{
        if strings.Index(rawUrl, "ws://") != 0 &amp;&amp; strings.Index(rawUrl, "wss://") != 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if _, err := url.ParseRequestURI(rawUrl); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
